import { tool } from "@openai/agents";
import { z } from "zod";
import { memoryDeduplicationService } from "../../services/memory-deduplication.service.js";
import { type DatabaseContext, type CreateMemoryInput, CORE_MEMORY_CATEGORIES } from "../../types/index.js";
import { readFile } from "../../utils/read-file.js";

/**
 * Tool: store_memory
 * Persists user memories (facts, preferences, notes) so they can be recalled later.
 * The agent should call this when the user explicitly asks to remember something
 * or when the message contains multiple distinct pieces of information.
 * 
 * IMPORTANT: All content must be stored in English for consistency and better embedding performance.
 * 
 * SMART DEDUPLICATION: Automatically detects similar existing memories and decides whether to
 * create new memories or update existing ones to prevent duplicates.
 */

// Single memory schema
const SingleMemoryParams = z.object({
  content: z.string().describe("Full text to remember in ENGLISH (can be multi-sentence). Translate from user's language if needed."),
  summary: z
    .string()
    .max(160)
    .nullish()
    .describe("Brief summary in ENGLISH used for retrieval; if omitted will be autogenerated."),
  tags: z
    .array(z.string())
    .nullish()
    .describe(`Memory tags in ENGLISH. MUST include at least one core category: ${CORE_MEMORY_CATEGORIES.join(', ')}. Add specific descriptive tags. Example: ['personal_info', 'developer', 'turkey']`),
});

// Array of memories for different contexts
const StoreMemoryParams = z.object({
  memories: z.array(SingleMemoryParams).min(1).describe("Array of memories with different contexts. Each memory should focus on a single topic or context rather than mixing multiple subjects."),
});

export const storeMemoryTool = tool({
  name: "store_memory",
  description: (await readFile('prompts/store-memory-tool.md'))
    .replace(/{CORE_CATEGORIES}/g, CORE_MEMORY_CATEGORIES.join(', ')),
  parameters: StoreMemoryParams,
  strict: true,
  execute: async (
    data: z.infer<typeof StoreMemoryParams>,
    context
  ) => {
    const dbCtx = (context as any)?.context as DatabaseContext | undefined;
    if (!dbCtx) {
      return "‚ö†Ô∏è Missing database context; cannot store memory.";
    }

    const results: string[] = [];
    const errors: string[] = [];

    // Prepare memory inputs
    const memoryInputs: CreateMemoryInput[] = [];

    for (let i = 0; i < data.memories.length; i++) {
      const memoryData = data.memories[i];
      if (!memoryData) continue;
      
      let { content, summary, tags } = memoryData;

      try {
        // Auto-generate summary if not provided (first 100 chars)
        if (!summary) {
          summary = content.length > 100 ? content.slice(0, 97) + "‚Ä¶" : content;
        }

        // Validate at least one core category exists
        if (tags && tags.length > 0) {
          const hasCoreCategory = tags.some((tag: string) => CORE_MEMORY_CATEGORIES.includes(tag as any));
          if (!hasCoreCategory) {
            errors.push(`Memory ${i + 1}: Please include at least one core category: ${CORE_MEMORY_CATEGORIES.join(', ')}`);
            continue;
          }
        } else {
          // If no tags provided, add a default 'note' category
          tags = ['note'];
        }

        const input: CreateMemoryInput = {
          // messageId can be omitted when the memory isn't tied to a specific message
          content,
          summary,
          tags,
        } as CreateMemoryInput;

        memoryInputs.push(input);
      } catch (error) {
        errors.push(`Memory ${i + 1}: ‚ùå Validation failed - ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }

    // Use smart deduplication service for batch processing
    if (memoryInputs.length > 0) {
      try {
        const smartResults = await memoryDeduplicationService.smartCreateMultipleMemories(memoryInputs, dbCtx);
        
        smartResults.forEach(({ index, result }) => {
          const memoryNum = index + 1;
          const actionEmoji = {
            created: '‚úÖ Created',
            updated: 'üîÑ Updated',
            skipped: '‚è≠Ô∏è Skipped'
          }[result.action];
          
          results.push(`Memory ${memoryNum}: ${actionEmoji} (id: ${result.memoryId}) - ${result.reason}`);
          
          if (result.similarMemories && result.similarMemories.length > 0) {
            results.push(`   üìé Found ${result.similarMemories.length} similar existing memories`);
          }
        });
      } catch (error) {
        errors.push(`Batch processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }

    // Build response summary
    const totalMemories = data.memories.length;
    const processedCount = memoryInputs.length;
    const errorCount = errors.length;

    let response = `üß† Smart Memory Processing: ${totalMemories} memories ‚Üí ${processedCount} processed, ${errorCount} errors\n\n`;
    
    if (results.length > 0) {
      response += results.join('\n') + '\n';
    }
    
    if (errors.length > 0) {
      response += '\n‚ùå Errors:\n' + errors.join('\n');
    }

    console.log(response);

    return response;
  },
}); 