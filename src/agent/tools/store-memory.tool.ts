import { type RunContext, tool } from "@openai/agents";
import { z } from "zod";
import { memoryDeduplicationService } from "../../services/memory-deduplication.service.js";
import {
  CORE_MEMORY_CATEGORIES,
  type CreateMemoryInput,
  type DatabaseContext,
  type GatewayContext,
} from "../../types/index.js";
import { readFile } from "../../utils/read-file.js";

/**
 * Tool: store_memory
 * Persists user memories (facts, preferences, notes) so they can be recalled later.
 * The agent should call this when the user explicitly asks to remember something
 * or when the message contains multiple distinct pieces of information.
 *
 * IMPORTANT: All content must be stored in English for consistency and better embedding performance.
 *
 * SMART DEDUPLICATION: Automatically detects similar existing memories and decides whether to
 * create new memories or update existing ones to prevent duplicates.
 */

// Single memory schema
const SingleMemoryParams = z.object({
  content: z
    .string()
    .describe(
      "Full text to remember in ENGLISH (can be multi-sentence). Translate from user's language if needed.",
    ),
  summary: z
    .string()
    .max(160)
    .nullish()
    .describe("Brief summary in ENGLISH used for retrieval; if omitted will be autogenerated."),
  tags: z
    .array(z.string())
    .nullish()
    .describe(
      `Memory tags in ENGLISH. MUST include at least one core category: ${CORE_MEMORY_CATEGORIES.join(", ")}. Add specific descriptive tags. Example: ['personal_info', 'developer', 'turkey']`,
    ),
});

// Array of memories for different contexts
const StoreMemoryParams = z.object({
  memories: z
    .array(SingleMemoryParams)
    .min(1)
    .describe(
      "Array of memories with different contexts. Each memory should focus on a single topic or context rather than mixing multiple subjects.",
    ),
});

type MemoryValidationResult =
  | {
      input: CreateMemoryInput;
      index: number;
    }
  | {
      error: string;
      index: number;
    };

type ProcessingStats = {
  totalMemories: number;
  processedCount: number;
  errorCount: number;
};

/**
 * Auto-generates a summary from content if not provided
 */
function generateSummary(content: string, providedSummary?: string | null): string {
  if (providedSummary) return providedSummary;
  return content.length > 100 ? `${content.slice(0, 97)}‚Ä¶` : content;
}

/**
 * Validates and normalizes tags, ensuring at least one core category exists
 */
function validateAndNormalizeTags(tags?: string[] | null): { tags: string[]; error?: string } {
  if (!tags || tags.length === 0) {
    return { tags: ["note"] };
  }

  const hasCoreCategory = tags.some((tag: string) => CORE_MEMORY_CATEGORIES.includes(tag as any));

  if (!hasCoreCategory) {
    return {
      tags: [],
      error: `Please include at least one core category: ${CORE_MEMORY_CATEGORIES.join(", ")}`,
    };
  }

  return { tags };
}

/**
 * Validates and prepares a single memory input
 */
function prepareSingleMemory(
  memoryData: z.infer<typeof SingleMemoryParams>,
  index: number,
): MemoryValidationResult {
  try {
    const { content } = memoryData;
    const summary = generateSummary(content, memoryData.summary);
    const { tags, error } = validateAndNormalizeTags(memoryData.tags);

    if (error) {
      return { error, index };
    }

    const input: CreateMemoryInput = {
      content,
      summary,
      tags,
    } as CreateMemoryInput;

    return { input, index };
  } catch (error) {
    return {
      error: `Validation failed - ${error instanceof Error ? error.message : "Unknown error"}`,
      index,
    };
  }
}

/**
 * Prepares multiple memory inputs, separating valid ones from errors
 */
function prepareMemoryInputs(memories: z.infer<typeof SingleMemoryParams>[]): {
  validInputs: CreateMemoryInput[];
  errors: string[];
} {
  const validInputs: CreateMemoryInput[] = [];
  const errors: string[] = [];

  for (let i = 0; i < memories.length; i++) {
    const memoryData = memories[i];
    if (!memoryData) continue;

    const result = prepareSingleMemory(memoryData, i);

    if ("error" in result) {
      errors.push(`Memory ${result.index + 1}: ‚ùå ${result.error}`);
    } else {
      validInputs.push(result.input);
    }
  }

  return { validInputs, errors };
}

/**
 * Formats the results from smart deduplication service
 */
function formatProcessingResults(smartResults: any[]): string[] {
  return smartResults.flatMap(({ index, result }) => {
    const memoryNum = index + 1;
    const actionEmojiMap = {
      created: "‚úÖ Created",
      updated: "üîÑ Updated",
      skipped: "‚è≠Ô∏è Skipped",
    } as const;

    const action = result.action as keyof typeof actionEmojiMap;
    const actionEmoji = actionEmojiMap[action] || "‚ùì Unknown";

    const lines = [
      `Memory ${memoryNum}: ${actionEmoji} (id: ${result.memoryId}) - ${result.reason}`,
    ];

    if (result.similarMemories && result.similarMemories.length > 0) {
      lines.push(`   üìé Found ${result.similarMemories.length} similar existing memories`);
    }

    return lines;
  });
}

/**
 * Builds the final response message
 */
function buildResponse(stats: ProcessingStats, results: string[], errors: string[]): string {
  const { totalMemories, processedCount, errorCount } = stats;

  let response = `üß† Smart Memory Processing: ${totalMemories} memories ‚Üí ${processedCount} processed, ${errorCount} errors\n\n`;

  if (results.length > 0) {
    response += `‚úÖ ${results.join("\n")}\n`;
  }

  if (errors.length > 0) {
    response += `\n‚ùå Errors:\n${errors.join("\n")}`;
  }

  return response;
}

/**
 * Processes valid memory inputs using the deduplication service
 */
async function processMemoriesWithDeduplication(
  validInputs: CreateMemoryInput[],
  dbCtx: DatabaseContext,
): Promise<{ results: string[]; errors: string[] }> {
  const results: string[] = [];
  const errors: string[] = [];

  if (validInputs.length === 0) {
    return { results, errors };
  }

  try {
    const smartResults = await memoryDeduplicationService.smartCreateMultipleMemories(
      validInputs,
      dbCtx,
    );
    const formattedResults = formatProcessingResults(smartResults);
    results.push(...formattedResults);
  } catch (error) {
    errors.push(
      `Batch processing failed: ${error instanceof Error ? error.message : "Unknown error"}`,
    );
  }

  return { results, errors };
}

export const storeMemoryTool = tool({
  name: "store_memory",
  description: (await readFile("src/agent/prompts/store-memory-tool.md")).replace(
    /{CORE_CATEGORIES}/g,
    CORE_MEMORY_CATEGORIES.join(", "),
  ),
  parameters: StoreMemoryParams,
  strict: true,
  execute: async (
    data: z.infer<typeof StoreMemoryParams>,
    runContext?: RunContext<GatewayContext>,
  ) => {
    const context = runContext?.context;
    if (!context) {
      return "‚ö†Ô∏è Missing database context; cannot store memory.";
    }

    // Prepare memory inputs and collect validation errors
    const { validInputs, errors: validationErrors } = prepareMemoryInputs(data.memories);

    // Process valid memories with smart deduplication
    const { results, errors: processingErrors } = await processMemoriesWithDeduplication(
      validInputs,
      context,
    );

    // Combine all errors
    const allErrors = [...validationErrors, ...processingErrors];

    // Build processing stats
    const stats: ProcessingStats = {
      totalMemories: data.memories.length,
      processedCount: validInputs.length,
      errorCount: allErrors.length,
    };

    // Build and return final response
    return buildResponse(stats, results, allErrors);
  },
});
